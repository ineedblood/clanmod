#include "cg_local.h"

//lmo undefine syscalls that have been re-routed here
#undef trap_S_StartSound
#undef trap_S_AddLoopingSound
#undef trap_S_AddRealLoopingSound

void	trap_S_StartSound( vec3_t origin, int entityNum, int entchannel, sfxHandle_t sfx );
void	trap_S_AddLoopingSound( int entityNum, const vec3_t origin, const vec3_t velocity, sfxHandle_t sfx );
void	trap_S_AddRealLoopingSound( int entityNum, const vec3_t origin, const vec3_t velocity, sfxHandle_t sfx );



void	nox_trap_S_StartSound( vec3_t origin, int entityNum, int entchannel, sfxHandle_t sfx ) {
	int doit = 1; //consider NonX (lmo)

	if ( cg.snap->ps.duelInProgress )
	{ // this client is dueling
		if ( entityNum >= 0 && entityNum < MAX_CLIENTS && entityNum != cg.snap->ps.clientNum &&
			entityNum != cg.snap->ps.duelIndex )
		{	// sound originated from a client, but not one of the duelers
			doit = 0;
		}
		else if ( entityNum >= MAX_CLIENTS &&
			cg_entities[entityNum].currentState.otherEntityNum != ENTITYNUM_NONE &&
			cg_entities[entityNum].currentState.otherEntityNum != cg.snap->ps.clientNum &&
			cg_entities[entityNum].currentState.otherEntityNum != cg.snap->ps.duelIndex )
		{  // sound generated by non-client (e.g. temp) entity in a snap, the otherEntityNum should be the orinating
		   // client number (by hack!). If otherEntityNum is ENTITYNUM_NONE, then it is one of the many sounds
		   // I don't bother filtering, so play it. Otherwise, if not from the duelers, supress it
			doit = 0;
		}
	}
	if ( doit ) {
		trap_S_StartSound( origin, entityNum, entchannel, sfx );
	}
}


void	nox_trap_S_AddLoopingSound( int entityNum, const vec3_t origin, const vec3_t velocity, sfxHandle_t sfx ) {
	int doit = 1; //consider NonX (lmo)

	if ( cg.snap->ps.duelInProgress )
	{ // this client is dueling
		if ( entityNum >= 0 && entityNum < MAX_CLIENTS && entityNum != cg.snap->ps.clientNum &&
			entityNum != cg.snap->ps.duelIndex )
		{	// sound originated from a client, but not one of the duelers
			doit = 0;
		}
		else if ( entityNum >= MAX_CLIENTS &&
			cg_entities[entityNum].currentState.otherEntityNum != ENTITYNUM_NONE &&
			cg_entities[entityNum].currentState.otherEntityNum != cg.snap->ps.clientNum &&
			cg_entities[entityNum].currentState.otherEntityNum != cg.snap->ps.duelIndex )
		{  // sound generated by an temp entity in a snap, the otherEntityNum should be the orinating
		   // client number (by hack!). If otherEntityNum is ENTITYNUM_NONE, then it is one of the many sounds
		   // I don't bother filtering, so play it. Otherwise, if not from the duelers, supress it
			doit = 0;
		}
	}
	if ( doit ) {
		trap_S_AddLoopingSound( entityNum, origin, velocity, sfx );
	}
}

void	nox_trap_S_AddRealLoopingSound( int entityNum, const vec3_t origin, const vec3_t velocity, sfxHandle_t sfx ) {
	int doit = 1; //consider NonX (lmo)

	if ( cg.snap->ps.duelInProgress )
	{ // this client is dueling
		if ( entityNum >= 0 && entityNum < MAX_CLIENTS && entityNum != cg.snap->ps.clientNum &&
			entityNum != cg.snap->ps.duelIndex )
		{	// sound originated from a client, but not one of the duelers
			doit = 0;
		}
		else if ( entityNum >= MAX_CLIENTS &&
			cg_entities[entityNum].currentState.otherEntityNum != ENTITYNUM_NONE &&
			cg_entities[entityNum].currentState.otherEntityNum != cg.snap->ps.clientNum &&
			cg_entities[entityNum].currentState.otherEntityNum != cg.snap->ps.duelIndex )
		{  // sound generated by an temp entity in a snap, the otherEntityNum should be the orinating
		   // client number (by hack!). If otherEntityNum is ENTITYNUM_NONE, then it is one of the many sounds
		   // I don't bother filtering, so play it. Otherwise, if not from the duelers, supress it
			doit = 0;
		}
	}
	if ( doit )
	{
		trap_S_AddRealLoopingSound( entityNum, origin, velocity, sfx );
	}
}
